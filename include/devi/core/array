#ifndef DEVI_CORE_ARRAY
#define DEVI_CORE_ARRAY

#include "dimension/shape"
#include "types"

namespace devi::core
{
  template<type _DType>
  class array;

  // array type aliases
  using bool8   = array<type::bool8>;
  using int8    = array<type::int8>;
  using int16   = array<type::int16>;
  using int32   = array<type::int32>;
  using int64   = array<type::int64>;
  using uint8   = array<type::uint8>;
  using uint16  = array<type::uint16>;
  using uint32  = array<type::uint32>;
  using uint64  = array<type::uint64>;
  using float32 = array<type::float32>;
  using float64 = array<type::float64>;

  template<type _DType>
  class array {
    using native_type = typename native_type<_DType>::type;

  public:

    /* Constructs a zero-initialized `array` with its shape specified by the argument `s`
     *
     * Errors:
     * `new` can throw an `std::bad_alloc` exception
     */
    array(const core::shape &s);
    array(core::shape &&s);

    /* Constructs an `array` with every element equal to `fill` and its shape specified by
     * the argument `s`
     *
     * Errors:
     * `new` can throw an `std::bad_alloc` exception
     */
    array(const core::shape &s, const native_type fill);
    array(core::shape &&s, const native_type fill);

    ~array() noexcept = default;

    //////////////////////// COPY-MOVE SEMANTICS /////////////////////////

    array(const array &copy);
    array(array &&move) noexcept;
    array &operator=(array rhs) noexcept;

    ///////////////////////// OPERATOR OVERLOADS /////////////////////////

    bool operator==(const array &other) const noexcept;
    bool operator!=(const array &other) const noexcept;
    native_type &operator[](const std::size_t flat_idx) noexcept;
    native_type operator[](const std::size_t flat_idx) const noexcept;

    ////////////////////////////// GETTERS ///////////////////////////////

    /* Return the value of array element at given index
     *
     * Errors:
     * `std::out_of_range` is thrown if argument `idx` fails the bounds check
     * */
    native_type &at(const std::size_t flat_idx);
    native_type at(const std::size_t flat_idx) const;

    // Returns the dimensionality of the array
    unsigned ndims() const noexcept;

    // Returns the shape of the array
    const core::shape &shape() const noexcept;

    // Returns the total size of the array
    std::size_t size() const noexcept;

    // Returns the `devi::core::type` of the array
    core::type type() const noexcept;

    ////////////////////////////// GENERAL ///////////////////////////////

    // Sets every element in the array to `value`
    void fill(const native_type value) noexcept;

    // Swap state with existing array
    void swap(array &b) noexcept;
    // Swap state with temporary array
    void swap(array &&b) noexcept;

  private:

    std::unique_ptr<native_type[]> p_data;
    core::shape m_shape;
  };

}  // namespace devi::core

//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// IMPLEMENTATION /////////////////////////////////////

namespace devi::core
{
  template<type _DType>
  array<_DType>::array(const core::shape &s)
    : p_data { new native_type[s.size()] {} }, m_shape { s }
  { }

  template<type _DType>
  array<_DType>::array(core::shape &&s)
    : p_data { new native_type[s.size()] {} }, m_shape { std::move(s) }
  { }

  template<type _DType>
  array<_DType>::array(const core::shape &s, const native_type fill) : array { s }
  {
    this->fill(fill);
  }

  template<type _DType>
  array<_DType>::array(core::shape &&s, const native_type fill) : array { std::move(s) }
  {
    this->fill(fill);
  }

  //////////////////////// COPY-MOVE SEMANTICS /////////////////////////

  template<type _DType>
  array<_DType>::array(const array &copy) : array { copy.m_shape }
  {
    std::copy_n(copy.p_data.get(), m_shape.size(), p_data.get());
  }

  template<type _DType>
  array<_DType>::array(array &&move) noexcept
    : p_data { std::move(move.p_data) }, m_shape { std::move(move.m_shape) }
  { }

  template<type _DType>
  array<_DType> &array<_DType>::operator=(array rhs) noexcept
  {
    this->swap(rhs);
    return *this;
  }

  ///////////////////////// OPERATOR OVERLOADS /////////////////////////

  template<type _DType>
  bool array<_DType>::operator==(const array &other) const noexcept
  {
    return m_shape == other.m_shape
        && std::equal(p_data.get(), p_data.get() + m_shape.size(), other.p_data.get());
  }

  template<type _DType>
  bool array<_DType>::operator!=(const array &other) const noexcept
  {
    return !(*this == other);
  }

  template<type _DType>
  typename array<_DType>::native_type &array<_DType>::operator[](
    const std::size_t flat_idx) noexcept
  {
    return p_data[flat_idx];
  }

  template<type _DType>
  typename array<_DType>::native_type array<_DType>::operator[](
    const std::size_t flat_idx) const noexcept
  {
    return const_cast<array &>(*this)[flat_idx];
  }

  ////////////////////////////// GETTERS ///////////////////////////////

  template<type _DType>
  typename array<_DType>::native_type &array<_DType>::at(const std::size_t flat_idx)
  {
    if (flat_idx >= m_shape.size()) throw std::out_of_range { "index out of bounds" };
    return (*this)[flat_idx];
  }

  template<type _DType>
  typename array<_DType>::native_type array<_DType>::at(const std::size_t flat_idx) const
  {
    return const_cast<array *>(this)->at(flat_idx);
  }

  template<type _DType>
  unsigned array<_DType>::ndims() const noexcept
  {
    return m_shape.ndims();
  }

  template<type _DType>
  const shape &array<_DType>::shape() const noexcept
  {
    return m_shape;
  }

  template<type _DType>
  std::size_t array<_DType>::size() const noexcept
  {
    return m_shape.size();
  }

  template<type _DType>
  type array<_DType>::type() const noexcept
  {
    return _DType;
  }

  ////////////////////////////// GENERAL ///////////////////////////////

  template<type _DType>
  void array<_DType>::fill(const native_type value) noexcept
  {
    std::fill_n(p_data.get(), m_shape.size(), value);
  }

  template<type _DType>
  void array<_DType>::swap(array &b) noexcept
  {
    std::swap(p_data, b.p_data);
    std::swap(m_shape, b.m_shape);
  }

  template<type _DType>
  void array<_DType>::swap(array &&b) noexcept
  {
    this->swap(b);
  }
}  // namespace devi::core

#endif
// vim: ft=cpp
