#ifndef _DEVI_CORE_ARRAY_
#define _DEVI_CORE_ARRAY_

#include "dimension/shape"
#include "types"

namespace devi::core
{
  template<type _DType>
  class array;

  // array type aliases
  using bool8   = array<type::bool8>;
  using int8    = array<type::int8>;
  using int16   = array<type::int16>;
  using int32   = array<type::int32>;
  using int64   = array<type::int64>;
  using uint8   = array<type::uint8>;
  using uint16  = array<type::uint16>;
  using uint32  = array<type::uint32>;
  using uint64  = array<type::uint64>;
  using float32 = array<type::float32>;
  using float64 = array<type::float64>;

  template<type _DType>
  class array {
    using native_type = typename native_type<_DType>::type;

  public:

    /* Constructs a zero-initialized `array` with its shape specified by the argument `s`
     *
     * Errors:
     * `new` can throw an `std::bad_alloc` exception
     */
    array(const core::shape &s);
    array(core::shape &&s);

    /* Constructs an `array` with every element equal to `fill` and its shape specified by
     * the argument `s`
     *
     * Errors:
     * `new` can throw an `std::bad_alloc` exception
     */
    array(const core::shape &s, const native_type fill);
    array(core::shape &&s, const native_type fill);

    ~array() noexcept = default;

    //////////////////////// COPY-MOVE SEMANTICS /////////////////////////

    array(const array &copy);
    array(array &&move) noexcept;
    array &operator=(array rhs) noexcept;

    ///////////////////////// OPERATOR OVERLOADS /////////////////////////

    // equality
    [[nodiscard]] bool operator==(const array &other) const noexcept;
    [[nodiscard]] bool operator!=(const array &other) const noexcept;

    // flat-indexing
    [[nodiscard]] native_type &operator[](const std::size_t flat_idx) noexcept;
    [[nodiscard]] native_type operator[](const std::size_t flat_idx) const noexcept;

    // multi-dimensional full-indexing
    template<typename... _Args>
    [[nodiscard]] native_type &operator()(const _Args... args);
    template<typename... _Args>
    [[nodiscard]] native_type operator()(const _Args... args) const;

    ////////////////////////////// GETTERS ///////////////////////////////

    /* Return the value of array element at given index
     *
     * Errors:
     * `std::out_of_range` is thrown if argument `idx` fails the bounds check
     * */
    [[nodiscard]] native_type &at(const std::size_t flat_idx);
    [[nodiscard]] native_type at(const std::size_t flat_idx) const;

    // Returns the dimensionality of the array
    [[nodiscard]] unsigned ndims() const noexcept;

    // Returns the shape of the array
    [[nodiscard]] const core::shape &shape() const noexcept;

    // Returns the total size of the array
    [[nodiscard]] std::size_t size() const noexcept;

    // Returns the `devi::core::type` of the array
    [[nodiscard]] core::type type() const noexcept;

    ////////////////////////////// CREATION //////////////////////////////

    // Returns a element-wise type-casted copy of the current array
    template<core::type _AsType>
    [[nodiscard]] array<_AsType> astype() const;

    // Returns a copy of the current array
    [[nodiscard]] array copy() const;

    ////////////////////////////// MUTATION //////////////////////////////

    // Sets every element in the array to `val`
    void fill(const native_type val) noexcept;

    // Flattens the current array to a single dimension
    void flatten();

    // Reshapes the current array
    template<typename... _Args>
    void reshape(const _Args... args);
    void reshape(const core::shape &s);
    void reshape(core::shape &&s) noexcept;

    // Squeeze the array shape to remove all unit dimensions
    void squeeze() noexcept;

    // Swap state with existing array
    void swap(array &b) noexcept;
    // Swap state with temporary array
    void swap(array &&b) noexcept;

  private:

    std::unique_ptr<native_type[]> p_data;
    core::shape m_shape;

    template<core::type _Other>
    friend class array;

  };  // class array

}  // namespace devi::core

//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// IMPLEMENTATION /////////////////////////////////////

#include "dimension/index"

namespace devi::core
{
  template<type _DType>
  array<_DType>::array(const core::shape &s)
    : p_data { new native_type[s.size()] {} }, m_shape { s }
  { }

  template<type _DType>
  array<_DType>::array(core::shape &&s)
    : p_data { new native_type[s.size()] {} }, m_shape { std::move(s) }
  { }

  template<type _DType>
  array<_DType>::array(const core::shape &s, const native_type fill) : array { s }
  {
    this->fill(fill);
  }

  template<type _DType>
  array<_DType>::array(core::shape &&s, const native_type fill) : array { std::move(s) }
  {
    this->fill(fill);
  }

  //////////////////////// COPY-MOVE SEMANTICS /////////////////////////

  template<type _DType>
  array<_DType>::array(const array &copy) : array { copy.m_shape }
  {
    std::copy_n(copy.p_data.get(), m_shape.size(), p_data.get());
  }

  template<type _DType>
  array<_DType>::array(array &&move) noexcept
    : p_data { std::move(move.p_data) }, m_shape { std::move(move.m_shape) }
  { }

  template<type _DType>
  array<_DType> &array<_DType>::operator=(array rhs) noexcept
  {
    this->swap(rhs);
    return *this;
  }

  ///////////////////////// OPERATOR OVERLOADS /////////////////////////

  template<type _DType>
  bool array<_DType>::operator==(const array &other) const noexcept
  {
    return m_shape == other.m_shape
        && std::equal(p_data.get(), p_data.get() + m_shape.size(), other.p_data.get());
  }

  template<type _DType>
  bool array<_DType>::operator!=(const array &other) const noexcept
  {
    return !(*this == other);
  }

  template<type _DType>
  typename array<_DType>::native_type &array<_DType>::operator[](
    const std::size_t flat_idx) noexcept
  {
    return p_data[flat_idx];
  }

  template<type _DType>
  typename array<_DType>::native_type array<_DType>::operator[](
    const std::size_t flat_idx) const noexcept
  {
    return const_cast<array &>(*this)[flat_idx];
  }

  template<type _DType>
  template<typename... _Args>
  typename array<_DType>::native_type &array<_DType>::operator()(const _Args... args)
  {
    if (sizeof...(args) != m_shape.ndims())
      throw std::out_of_range { "index must have same dimensionality as array shape" };

    return p_data[index { args... }.flat(m_shape)];
  }

  template<type _DType>
  template<typename... _Args>
  typename array<_DType>::native_type array<_DType>::operator()(const _Args... args) const
  {
    return const_cast<array &>(*this)(args...);
  }

  ////////////////////////////// GETTERS ///////////////////////////////

  template<type _DType>
  typename array<_DType>::native_type &array<_DType>::at(const std::size_t flat_idx)
  {
    if (flat_idx >= m_shape.size()) throw std::out_of_range { "index out of bounds" };

    return (*this)[flat_idx];
  }

  template<type _DType>
  typename array<_DType>::native_type array<_DType>::at(const std::size_t flat_idx) const
  {
    return const_cast<array *>(this)->at(flat_idx);
  }

  template<type _DType>
  unsigned array<_DType>::ndims() const noexcept
  {
    return m_shape.ndims();
  }

  template<type _DType>
  const shape &array<_DType>::shape() const noexcept
  {
    return m_shape;
  }

  template<type _DType>
  std::size_t array<_DType>::size() const noexcept
  {
    return m_shape.size();
  }

  template<type _DType>
  type array<_DType>::type() const noexcept
  {
    return _DType;
  }

  ////////////////////////////// CREATION //////////////////////////////

  template<type _DType>
  template<type _AsType>
  array<_AsType> array<_DType>::astype() const
  {
    array<_AsType> ret { m_shape };
    std::transform(p_data.get(), p_data.get() + m_shape.size(), ret.p_data.get(),
      [](const native_type val) {
        return static_cast<typename core::native_type<_AsType>::type>(val);
      });

    return ret;
  }

  template<type _DType>
  array<_DType> array<_DType>::copy() const
  {
    return array { *this };
  }

  ////////////////////////////// MUTATION //////////////////////////////

  template<type _DType>
  void array<_DType>::fill(const native_type val) noexcept
  {
    std::fill_n(p_data.get(), m_shape.size(), val);
  }

  template<type _DType>
  void array<_DType>::flatten()
  {
    this->reshape(m_shape.size());
  }

  template<type _DType>
  template<typename... _Args>
  void array<_DType>::reshape(const _Args... args)
  {
    this->reshape(core::shape { args... });
  }

  template<type _DType>
  void array<_DType>::reshape(const core::shape &s)
  {
    m_shape = s;
  }

  template<type _DType>
  void array<_DType>::reshape(core::shape &&s) noexcept
  {
    m_shape = std::move(s);
  }

  template<type _DType>
  void array<_DType>::squeeze() noexcept
  {
    m_shape.squeeze();
  }

  template<type _DType>
  void array<_DType>::swap(array &b) noexcept
  {
    std::swap(p_data, b.p_data);
    std::swap(m_shape, b.m_shape);
  }

  template<type _DType>
  void array<_DType>::swap(array &&b) noexcept
  {
    this->swap(b);
  }

}  // namespace devi::core

#endif
// vim: ft=cpp
