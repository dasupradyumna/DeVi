#ifndef DEVI_CORE_ARRAY
#define DEVI_CORE_ARRAY

#include "dimension/shape"
#include "types"

namespace devi::core
{
  template<type _DType>
  class array;

  // array type aliases
  using bool8   = array<type::bool8>;
  using int8    = array<type::int8>;
  using int16   = array<type::int16>;
  using int32   = array<type::int32>;
  using int64   = array<type::int64>;
  using uint8   = array<type::uint8>;
  using uint16  = array<type::uint16>;
  using uint32  = array<type::uint32>;
  using uint64  = array<type::uint64>;
  using float32 = array<type::float32>;
  using float64 = array<type::float64>;

  template<type _DType>
  class array {
    using native_type = typename native_type<_DType>::type;

  public:

    /* Constructs a zero-initialized `array` with its shape specified by the argument `s`
     *
     * Errors:
     * `new` can throw an `std::bad_alloc` exception
     */
    array(const shape &s);
    array(shape &&s);

    /* Constructs an `array` with every element equal to `fill` and its shape specified by
     * the argument `s`
     *
     * Errors:
     * `new` can throw an `std::bad_alloc` exception
     */
    array(const shape &s, const native_type fill);
    array(shape &&s, const native_type fill);

    ~array() noexcept = default;

    //////////////////////// COPY-MOVE SEMANTICS /////////////////////////

    array(const array &copy);
    array(array &&move) noexcept;
    array &operator=(array rhs) noexcept;

    ////////////////////////////// GENERAL ///////////////////////////////

    // Sets every element in the array to `value`
    void fill(const native_type value) noexcept;

    // Swap state with existing array
    void swap(array &b) noexcept;
    // Swap state with temporary array
    void swap(array &&b) noexcept;

  private:

    std::unique_ptr<native_type[]> p_data;
    shape m_shape;
  };

}  // namespace devi::core

//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// IMPLEMENTATION /////////////////////////////////////

namespace devi::core
{
  template<type _DType>
  array<_DType>::array(const shape &s)
    : p_data { new native_type[s.size()] {} }, m_shape { s }
  { }

  template<type _DType>
  array<_DType>::array(shape &&s)
    : p_data { new native_type[s.size()] {} }, m_shape { std::move(s) }
  { }

  template<type _DType>
  array<_DType>::array(const shape &s, const native_type fill) : array { s }
  {
    this->fill(fill);
  }

  template<type _DType>
  array<_DType>::array(shape &&s, const native_type fill) : array { std::move(s) }
  {
    this->fill(fill);
  }

  //////////////////////// COPY-MOVE SEMANTICS /////////////////////////

  template<type _DType>
  array<_DType>::array(const array &copy) : array { copy.m_shape }
  {
    std::copy_n(copy.p_data.get(), m_shape.size(), p_data.get());
  }

  template<type _DType>
  array<_DType>::array(array &&move) noexcept
    : p_data { std::move(move.p_data) }, m_shape { std::move(move.m_shape) }
  { }

  template<type _DType>
  array<_DType> &array<_DType>::operator=(array rhs) noexcept
  {
    this->swap(rhs);
    return *this;
  }

  ////////////////////////////// GENERAL ///////////////////////////////

  template<type _DType>
  void array<_DType>::fill(const native_type value) noexcept
  {
    std::fill_n(p_data.get(), m_shape.size(), value);
  }

  template<type _DType>
  void array<_DType>::swap(array &b) noexcept
  {
    std::swap(p_data, b.p_data);
    std::swap(m_shape, b.m_shape);
  }

  template<type _DType>
  void array<_DType>::swap(array &&b) noexcept
  {
    this->swap(b);
  }
}  // namespace devi::core

#endif
// vim: ft=cpp
